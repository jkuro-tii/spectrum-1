diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 264eb398f..ad90e4dcb 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -8,6 +8,7 @@ obj-$(CONFIG_TTY_PRINTK)	+= ttyprintk.o
 obj-y				+= misc.o
 obj-$(CONFIG_ATARI_DSP56K)	+= dsp56k.o
 obj-$(CONFIG_VIRTIO_CONSOLE)	+= virtio_console.o
+obj-$(CONFIG_VIRTIO_PMEM_CHAR)	+= virtio_pmem_char.o
 obj-$(CONFIG_MSPEC)		+= mspec.o
 obj-$(CONFIG_UV_MMTIMER)	+= uv_mmtimer.o
 obj-$(CONFIG_IBM_BSR)		+= bsr.o
diff --git a/drivers/char/mem.c b/drivers/char/mem.c
index cc296f082..7f7a96fed 100644
--- a/drivers/char/mem.c
+++ b/drivers/char/mem.c
@@ -359,7 +359,7 @@ static const struct vm_operations_struct mmap_mem_ops = {
 #endif
 };
 
-static int mmap_mem(struct file *file, struct vm_area_struct *vma)
+static int pmem_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	size_t size = vma->vm_end - vma->vm_start;
 	phys_addr_t offset = (phys_addr_t)vma->vm_pgoff << PAGE_SHIFT;
@@ -588,7 +588,7 @@ static loff_t null_lseek(struct file *file, loff_t offset, int orig)
  * also note that seeking relative to the "end of file" isn't supported:
  * it has no meaning, so it returns -EINVAL.
  */
-static loff_t memory_lseek(struct file *file, loff_t offset, int orig)
+static loff_t pmem_lseek(struct file *file, loff_t offset, int orig)
 {
 	loff_t ret;
 
@@ -645,10 +645,10 @@ static int open_port(struct inode *inode, struct file *filp)
 #define open_mem	open_port
 
 static const struct file_operations __maybe_unused mem_fops = {
-	.llseek		= memory_lseek,
+	.llseek		= pmem_lseek,
 	.read		= read_mem,
 	.write		= write_mem,
-	.mmap		= mmap_mem,
+	.mmap		= pmem_mmap,
 	.open		= open_mem,
 #ifndef CONFIG_MMU
 	.get_unmapped_area = get_unmapped_area_mem,
@@ -666,7 +666,7 @@ static const struct file_operations null_fops = {
 };
 
 static const struct file_operations __maybe_unused port_fops = {
-	.llseek		= memory_lseek,
+	.llseek		= pmem_lseek,
 	.read		= read_port,
 	.write		= write_port,
 	.open		= open_port,
diff --git a/drivers/char/virtio_pmem_char.c b/drivers/char/virtio_pmem_char.c
new file mode 100644
index 000000000..91afb9050
--- /dev/null
+++ b/drivers/char/virtio_pmem_char.c
@@ -0,0 +1,261 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * virtio_pmem.c: Virtio pmem char Driver
+ *
+ * Discovers persistent memory range information
+ * from host and registers the virtual pmem device
+ * with libnvdimm core.
+ */
+#include <linux/major.h>
+#include <linux/ioport.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include "virtio_pmem_char.h"
+
+static struct virtio_device_id id_table[] = {
+	{ VIRTIO_ID_PMEM, VIRTIO_DEV_ANY_ID },
+	{ 0 },
+};
+
+static struct virtio_pmem *vpmem = NULL;
+static struct miscdevice pmem_miscdev;
+
+/* Initialize virt queue */
+static int init_vq(struct virtio_pmem *vpmem)
+{
+	/* single vq */
+	vpmem->req_vq = virtio_find_single_vq(vpmem->vdev, virtio_pmem_host_ack,
+					      "flush_queue");
+	if (IS_ERR(vpmem->req_vq))
+		return PTR_ERR(vpmem->req_vq);
+
+	spin_lock_init(&vpmem->pmem_lock);
+	INIT_LIST_HEAD(&vpmem->req_list);
+
+	return 0;
+};
+
+static loff_t pmem_lseek(struct file *filp, loff_t off, int whence)
+{
+	loff_t newpos;
+
+	switch (whence) {
+	case SEEK_SET:
+		if (off >= vpmem->size) {
+			newpos = -ESPIPE;
+			goto out;
+		}
+		newpos = off;
+		break;
+
+	case SEEK_CUR:
+		newpos = filp->f_pos + off;
+		if (newpos >= vpmem->size) {
+			newpos = -ESPIPE;
+			goto out;
+		}
+		break;
+
+	case SEEK_END:
+		newpos = vpmem->size;
+		break;
+
+	default: /* can't happen */
+		newpos = -EINVAL;
+		goto out;
+	}
+
+	filp->f_pos = newpos;
+out:
+	return newpos;
+}
+
+static ssize_t pmem_write(struct file *file, const char __user *buf,
+			  size_t count, loff_t *ppos)
+{
+	loff_t pos = *ppos;
+	void *pmem_addr, *temp_buf = NULL;
+	unsigned long long map_start_addr;
+
+	if (count > vpmem->size - pos)
+		count = vpmem->size - pos;
+	if (!count)
+		return 0;
+
+	map_start_addr = vpmem->start + pos;
+	pmem_addr = ioremap(map_start_addr, count);
+	if (!pmem_addr) {
+		pr_err("ioremap failed");
+		return -ENOMEM;
+	}
+	temp_buf = kmalloc(count, GFP_USER);
+	if (!temp_buf) {
+		pr_err("kmalloc failed");
+		count = -ENOMEM;
+		goto out;
+	}
+	pr_info("WW map_start_addr: %p pmem_addr: %p temp_buf: %p",
+		map_start_addr, pmem_addr, temp_buf);
+
+	if (copy_from_user(temp_buf, buf, count)) {
+		pr_err("copy_from_user failed");
+		count = -EFAULT;
+		goto out;
+	}
+	memcpy_toio(pmem_addr, temp_buf, count);
+
+	*ppos += count;
+out:
+	iounmap(pmem_addr);
+	if (temp_buf)
+		kfree(temp_buf);
+
+	return count;
+}
+
+static ssize_t pmem_read(struct file *file, char __user *buf, size_t count,
+			 loff_t *ppos)
+{
+	loff_t pos = *ppos;
+	void *pmem_addr, *temp_buf = NULL;
+	unsigned long long map_start_addr;
+
+	if (count > vpmem->size - pos)
+		count = vpmem->size - pos;
+	if (!count)
+		return 0;
+
+	map_start_addr = vpmem->start + pos;
+	pmem_addr = ioremap(map_start_addr, count);
+	if (!pmem_addr) {
+		pr_err("ioremap failed");
+		return -ENOMEM;
+	}
+	temp_buf = kmalloc(count, GFP_USER);
+	if (!temp_buf)
+	{
+		pr_err("kmalloc failed");
+		count = -ENOMEM;
+		goto out;
+	}
+	pr_info("RR map_start_addr: %p pmem_addr: %p temp_buf: %p",
+		map_start_addr, pmem_addr, temp_buf);
+
+	memcpy_fromio(temp_buf, pmem_addr, count);
+
+	if (copy_to_user(buf, temp_buf, count)) {
+		pr_info("copy_to_user failed");
+		count = -EFAULT;
+		goto out;
+	}
+	*ppos += count;
+
+out:
+	iounmap(pmem_addr);
+	if (temp_buf)
+		kfree(temp_buf);
+
+	return count;
+}
+
+static int pmem_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	pr_info("JK: %s", __FUNCTION__);
+	printk(">>vpmem->start=0x%llx vpmem->size=0x%llx", vpmem->start,
+	       vpmem->size);
+
+	pr_info(">>phys_mem_access_prot=0x%x",
+		phys_mem_access_prot(file, vma->vm_pgoff, vpmem->size,
+				     vma->vm_page_prot));
+
+	pr_info(">>pgprot_noncached=0x%x", pgprot_noncached(vma->vm_page_prot));
+
+	pr_info(">>vma->vm_flags=0x%lx", vma->vm_flags);
+	pr_info(">>added flags: vma->vm_flags=0x%x", vma->vm_flags);
+	if (vm_iomap_memory(vma, vpmem->start, vpmem->size) < 0) {
+		pr_err("could not map the address area\n");
+		return -EIO;
+	}
+	pr_info(">>vma flags: vma->vm_flags=0x%lx", vma->vm_flags);
+	vma->vm_flags = VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP |
+			VM_MIXEDMAP | VM_READ | VM_WRITE;
+
+	return 0;
+}
+
+static const struct file_operations __maybe_unused pmem_fops = {
+	.llseek = 	pmem_lseek,
+	.read 	= 	pmem_read,
+	.write 	= 	pmem_write,
+	.mmap 	= 	pmem_mmap,
+};
+
+static int virtio_pmem_probe(struct virtio_device *vdev)
+{
+	struct resource *req;
+	int err = 0;
+
+	if (!vdev->config->get) {
+		dev_err(&vdev->dev, "%s failure: config access disabled\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	vpmem = devm_kzalloc(&vdev->dev, sizeof(*vpmem), GFP_KERNEL);
+	if (!vpmem) {
+		err = -ENOMEM;
+		goto out_err;
+	}
+	vpmem->vdev = vdev;
+	vdev->priv = vpmem;
+	err = init_vq(vpmem);
+	if (err) {
+		dev_err(&vdev->dev, "failed to initialize virtio pmem vq's\n");
+		goto out_err;
+	}
+
+	virtio_cread_le(vpmem->vdev, struct virtio_pmem_config, start,
+			&vpmem->start);
+	virtio_cread_le(vpmem->vdev, struct virtio_pmem_config, size,
+			&vpmem->size);
+
+	req = devm_request_mem_region(&vdev->dev, vpmem->start, vpmem->size,
+				      dev_name(&vdev->dev));
+	if (!req) {
+		dev_warn(&vdev->dev, "could not reserve region\n");
+	} else {
+		dev_info(&vdev->dev, "reserved region %pR\n", req);
+	}
+
+	return misc_register(&pmem_miscdev);
+
+out_err:
+	return err;
+}
+
+static void virtio_pmem_remove(struct virtio_device *vdev)
+{
+	vdev->config->del_vqs(vdev);
+	virtio_reset_device(vdev);
+	devm_release_mem_region(&vdev->dev, vpmem->start, vpmem->size);
+	misc_deregister(&pmem_miscdev);
+}
+
+static struct virtio_driver virtio_pmem_driver = {
+	.driver.name 	= KBUILD_MODNAME,
+	.driver.owner 	= THIS_MODULE,
+	.id_table 		= id_table,
+	.probe 			= virtio_pmem_probe,
+	.remove 		= virtio_pmem_remove,
+};
+
+static struct miscdevice pmem_miscdev = {
+	.minor 	= MISC_DYNAMIC_MINOR,
+	.name 	= "pmem_char",
+	.fops 	= &pmem_fops,
+};
+
+module_virtio_driver(virtio_pmem_driver);
+MODULE_DEVICE_TABLE(virtio, id_table);
+MODULE_DESCRIPTION("Virtio pmem char driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/char/virtio_pmem_char.h b/drivers/char/virtio_pmem_char.h
new file mode 100644
index 000000000..21012a516
--- /dev/null
+++ b/drivers/char/virtio_pmem_char.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * virtio_pmem_char.h: virtio pmem character Driver
+ *
+ * Discovers persistent memory range information
+ * from host and provides a character device.
+ **/
+
+#ifndef _LINUX_VIRTIO_PMEM_CHAR_H
+#define _LINUX_VIRTIO_PMEM_CHAR_H
+
+#include <linux/module.h>
+#include <uapi/linux/virtio_pmem.h>
+#include <linux/libnvdimm.h>
+#include <linux/spinlock.h>
+
+struct virtio_pmem_request {
+	struct virtio_pmem_req req;
+	struct virtio_pmem_resp resp;
+
+	/* Wait queue to process deferred work after ack from host */
+	wait_queue_head_t host_acked;
+	bool done;
+
+	/* Wait queue to process deferred work after virt queue buffer avail */
+	wait_queue_head_t wq_buf;
+	bool wq_buf_avail;
+	struct list_head list;
+};
+
+struct virtio_pmem {
+	struct virtio_device *vdev;
+
+	/* Virtio pmem request queue */
+	struct virtqueue *req_vq;
+
+	/* List to store deferred work if virtqueue is full */
+	struct list_head req_list;
+
+	/* Synchronize virtqueue data */
+	spinlock_t pmem_lock;
+
+	/* Memory region information */
+	__u64 start;
+	__u64 size;
+};
+
+void virtio_pmem_host_ack(struct virtqueue *vq);
+int async_pmem_flush(struct nd_region *nd_region, struct bio *bio);
+#endif
diff --git a/drivers/nvdimm/Makefile b/drivers/nvdimm/Makefile
index ba0296dca..f3c285f62 100644
--- a/drivers/nvdimm/Makefile
+++ b/drivers/nvdimm/Makefile
@@ -5,6 +5,7 @@ obj-$(CONFIG_ND_BTT) += nd_btt.o
 obj-$(CONFIG_X86_PMEM_LEGACY) += nd_e820.o
 obj-$(CONFIG_OF_PMEM) += of_pmem.o
 obj-$(CONFIG_VIRTIO_PMEM) += virtio_pmem.o nd_virtio.o
+obj-$(CONFIG_VIRTIO_PMEM_CHAR) += nd_virtio.o
 
 nd_pmem-y := pmem.o
 
diff --git a/drivers/virtio/Kconfig b/drivers/virtio/Kconfig
index b5adf6abd..f122fb846 100644
--- a/drivers/virtio/Kconfig
+++ b/drivers/virtio/Kconfig
@@ -85,6 +85,7 @@ config VIRTIO_PMEM
 	tristate "Support for virtio pmem driver"
 	depends on VIRTIO
 	depends on LIBNVDIMM
+	depends on VIRTIO_PMEM_CHAR = "n"
 	help
 	  This driver provides access to virtio-pmem devices, storage devices
 	  that are mapped into the physical address space - similar to NVDIMMs
@@ -92,6 +93,16 @@ config VIRTIO_PMEM
 
 	  If unsure, say Y.
 
+config VIRTIO_PMEM_CHAR
+	tristate "Support for virtio pmem char driver"
+	select VIRTIO
+	default m
+	help
+	  Virtio memory sharing for use with hypervisors.
+
+	  Enables driver for the /dev/misc/pmem_char device which may be used
+	  for sharing memory with other virtual machines.
+
 config VIRTIO_BALLOON
 	tristate "Virtio balloon driver"
 	depends on VIRTIO
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 9f44254af..16f5fec27 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -2897,12 +2897,12 @@ static inline vm_fault_t vmf_insert_page(struct vm_area_struct *vma,
 
 	return VM_FAULT_NOPAGE;
 }
-
 #ifndef io_remap_pfn_range
 static inline int io_remap_pfn_range(struct vm_area_struct *vma,
 				     unsigned long addr, unsigned long pfn,
 				     unsigned long size, pgprot_t prot)
 {
+	dump_stack();
 	return remap_pfn_range(vma, addr, pfn, size, pgprot_decrypted(prot));
 }
 #endif
diff --git a/mm/memory.c b/mm/memory.c
index 76e3af963..81df3e5d6 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -2456,6 +2456,7 @@ int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,
 {
 	int err;
 
+	dump_stack();
 	err = track_pfn_remap(vma, &prot, pfn, addr, PAGE_ALIGN(size));
 	if (err)
 		return -EINVAL;
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 0e4203838..911350983 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -6687,6 +6687,7 @@ void __ref memmap_init_zone_device(struct zone *zone,
 	unsigned long start = jiffies;
 	int nid = pgdat->node_id;
 
+	dump_stack();
 	if (WARN_ON_ONCE(!pgmap || zone_idx(zone) != ZONE_DEVICE))
 		return;
 
